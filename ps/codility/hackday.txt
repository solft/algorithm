1번

// a -> b로 갈때 드는 비용
fun move(a: Int, b: Int): Int {
    return when {
        a == b -> 0
        a +b == 7 -> 2
        else -> 1
    }
}

fun solution(A: IntArray): Int {
    var ans = 1000000000
    for(i in 1 .. 6){
        var tempAns = 0
        for(j in A){
            tempAns += move(j, i)
        }

        if(tempAns < ans)
            ans = tempAns
    }
    return ans
}


2번
import java.util.HashMap;

import static java.lang.Integer.max;

public class Tree {
    public int x;
    public Tree l;
    public Tree r;

    public int findDistinct(Tree node, HashMap<Integer, Integer> d) {
        if(node == null)
            return d.size();

        d.putIfAbsent(node.x, 0);
        d.put(node.x, d.get(node.x) + 1);

        int distinctValue = max(findDistinct(node.l, d), findDistinct(node.r, d));

        d.put(node.x, d.get(node.x) - 1);
        if(d.get(node.x) == 0)
            d.remove(node.x);

        return distinctValue;
    }

    public int solution(Tree T) {
        if(T == null)
            return 0;

        HashMap<Integer, Integer> distinctHash = new HashMap<>();

        return findDistinct(T, distinctHash);
    }

    public static void main() {

    }
}



3번


// -> 이 방향으로 최댓값 구하고
// <- 이 방향으로 최솟값 구하기
fun solution(T: IntArray): Int {
    var ans = 0

    val length = T.size
    val winterToSummer = IntArray(length)
    val summerToWinter = IntArray(length)

    var winterMax = -1_000_000_001
    var summerMin = 1_000_000_001
    for(winterIndex in 0 until length) {
        val summerIndex = length - winterIndex - 1

        if(winterMax < T[winterIndex])
            winterMax = T[winterIndex]
        if(summerMin > T[summerIndex])
            summerMin = T[summerIndex]

        // -> 방향 최대 온도 배열 만들기
        winterToSummer[winterIndex] = winterMax
        // <- 방향 최저 온도 배열 만들기
        summerToWinter[summerIndex] = summerMin
    }

//    winterToSummer.forEach { i -> print("$i ") }
//    println()
//    summerToWinter.forEach { i -> print("$i ") }
//    println()

    for(i in 1 until length){
        // i-1 까지 최대 온도가 i 까지 최저 온도보다 낮으면
        // 인덱스 i 부터 여름
        if(winterToSummer[i - 1] < summerToWinter[i]) {
            ans = i
            break
        }
    }

    return ans
}
